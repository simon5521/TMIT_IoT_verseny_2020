/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef MAINCTRL_H_
#define MAINCTRL_H_


#include "sc_types.h"
#include "StatemachineInterface.h"

/*! \file Header of the state machine 'Mainctrl'.
*/


/*! Define indices of states in the StateConfVector */
#define SCVI_MAIN_REGION_MAIN 0
#define SCVI_MAIN_REGION_MAIN_OPERATION_OFF 0
#define SCVI_MAIN_REGION_MAIN_OPERATION_ON 0
#define SCVI_MAIN_REGION_MAIN_OPERATION_ON_R1_NORMALOPERATION 0
#define SCVI_MAIN_REGION_MAIN_OPERATION_ON_R1_WARNING 0
#define SCVI_MAIN_REGION_MAIN_EVALUATION_WORKING 1
#define SCVI_MAIN_REGION_MAIN_EVALUATION_SHUTDOWNSTATE 1
#define SCVI_MAIN_REGION_MAIN_EVALUATION_SELFSTEERINGSTATE 1


class Mainctrl : public StatemachineInterface
{
	public:
		Mainctrl();
		
		virtual ~Mainctrl();
		
		/*! Enumeration of all states */ 
		typedef enum
		{
			Mainctrl_last_state,
			main_region_main,
			main_region_main_operation_Off,
			main_region_main_operation_On,
			main_region_main_operation_On_r1_NormalOperation,
			main_region_main_operation_On_r1_Warning,
			main_region_main_evaluation_working,
			main_region_main_evaluation_ShutdownState,
			main_region_main_evaluation_SelfSteeringState
		} MainctrlStates;
					
		static const sc_integer numStates = 8;
		
		//! Inner class for Monitor interface scope.
		class SCI_Monitor
		{
			public:
				/*! Checks if the out event 'warning' that is defined in the interface scope 'Monitor' has been raised. */
				sc_boolean isRaised_warning() const;
				
				
				/*! Checks if the out event 'selfsteering' that is defined in the interface scope 'Monitor' has been raised. */
				sc_boolean isRaised_selfsteering() const;
				
				
				/*! Checks if the out event 'loa' that is defined in the interface scope 'Monitor' has been raised. */
				sc_boolean isRaised_loa() const;
				
				
				
			private:
				friend class Mainctrl;
				sc_boolean warning_raised;
				sc_boolean selfsteering_raised;
				sc_boolean loa_raised;
				
				
		};
		
		/*! Returns an instance of the interface class 'SCI_Monitor'. */
		SCI_Monitor* getSCI_Monitor();
		
		//! Inner class for S1HW interface scope.
		class SCI_S1HW
		{
			public:
				/*! Raises the in event 'det' that is defined in the interface scope 'S1HW'. */
				void raise_det();
				
				
				/*! Raises the in event 'latent' that is defined in the interface scope 'S1HW'. */
				void raise_latent();
				
				
				
			private:
				friend class Mainctrl;
				sc_boolean det_raised;
				sc_boolean latent_raised;
				
				
		};
		
		/*! Returns an instance of the interface class 'SCI_S1HW'. */
		SCI_S1HW* getSCI_S1HW();
		
		//! Inner class for S2HW interface scope.
		class SCI_S2HW
		{
			public:
				/*! Raises the in event 'det' that is defined in the interface scope 'S2HW'. */
				void raise_det();
				
				
				/*! Raises the in event 'latent' that is defined in the interface scope 'S2HW'. */
				void raise_latent();
				
				
				
			private:
				friend class Mainctrl;
				sc_boolean det_raised;
				sc_boolean latent_raised;
				
				
		};
		
		/*! Returns an instance of the interface class 'SCI_S2HW'. */
		SCI_S2HW* getSCI_S2HW();
		
		//! Inner class for S3HW interface scope.
		class SCI_S3HW
		{
			public:
				/*! Raises the in event 'det' that is defined in the interface scope 'S3HW'. */
				void raise_det();
				
				
				/*! Raises the in event 'latent' that is defined in the interface scope 'S3HW'. */
				void raise_latent();
				
				
				
			private:
				friend class Mainctrl;
				sc_boolean det_raised;
				sc_boolean latent_raised;
				
				
		};
		
		/*! Returns an instance of the interface class 'SCI_S3HW'. */
		SCI_S3HW* getSCI_S3HW();
		
		//! Inner class for UCHW interface scope.
		class SCI_UCHW
		{
			public:
				/*! Raises the in event 'shutdown' that is defined in the interface scope 'UCHW'. */
				void raise_shutdown();
				
				
				
			private:
				friend class Mainctrl;
				sc_boolean shutdown_raised;
				
				
		};
		
		/*! Returns an instance of the interface class 'SCI_UCHW'. */
		SCI_UCHW* getSCI_UCHW();
		
		
		/*
		 * Functions inherited from StatemachineInterface
		 */
		virtual void init();
		
		virtual void enter();
		
		virtual void exit();
		
		virtual void runCycle();
		
		/*!
		* Checks if the state machine is active (until 2.4.1 this method was used for states).
		* A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
		*/
		virtual sc_boolean isActive() const;
		
		
		/*!
		* Checks if all active states are final. 
		* If there are no active states then the state machine is considered being inactive. In this case this method returns false.
		*/
		virtual sc_boolean isFinal() const;
		
		
		/*! Checks if the specified state is active (until 2.4.1 the used method for states was calles isActive()). */
		sc_boolean isStateActive(MainctrlStates state) const;
		
		
		
	protected:
		
		
	private:
		
		//! Inner class for internal interface scope.
		class InternalSCI
		{
			public:
				/*! Gets the value of the variable 'onsensors' that is defined in the internal scope. */
				sc_integer get_onsensors() const;
				
				/*! Sets the value of the variable 'onsensors' that is defined in the internal scope. */
				void set_onsensors(sc_integer value);
				
				
				/*! Gets the value of the variable 'oksensors' that is defined in the internal scope. */
				sc_integer get_oksensors() const;
				
				/*! Sets the value of the variable 'oksensors' that is defined in the internal scope. */
				void set_oksensors(sc_integer value);
				
				
				/*! Gets the value of the variable 'offsensors' that is defined in the internal scope. */
				sc_integer get_offsensors() const;
				
				/*! Sets the value of the variable 'offsensors' that is defined in the internal scope. */
				void set_offsensors(sc_integer value);
				
				
				/*! Gets the value of the variable 'latentsensors' that is defined in the internal scope. */
				sc_integer get_latentsensors() const;
				
				/*! Sets the value of the variable 'latentsensors' that is defined in the internal scope. */
				void set_latentsensors(sc_integer value);
				
				
				
			private:
				friend class Mainctrl;
				sc_integer onsensors;
				sc_integer oksensors;
				sc_integer offsensors;
				sc_integer latentsensors;
				
				
		};
		
		//! the maximum number of orthogonal states defines the dimension of the state configuration vector.
		static const sc_ushort maxOrthogonalStates = 2;
		
		
		
		MainctrlStates stateConfVector[maxOrthogonalStates];
		
		sc_ushort stateConfVectorPosition;
		
		SCI_Monitor ifaceMonitor;
		SCI_S1HW ifaceS1HW;
		SCI_S2HW ifaceS2HW;
		SCI_S3HW ifaceS3HW;
		SCI_UCHW ifaceUCHW;
		InternalSCI ifaceInternalSCI;
		
		// prototypes of all internal functions
		
		sc_boolean check_main_region_main_operation__choice_0_tr0_tr0();
		sc_boolean check_main_region_main_evaluation__choice_0_tr0_tr0();
		void effect_main_region_main_operation__choice_0_tr0();
		void effect_main_region_main_operation__choice_0_tr1();
		void effect_main_region_main_evaluation__choice_0_tr0();
		void effect_main_region_main_evaluation__choice_0_tr1();
		void enact_main_region_main_operation_Off();
		void enact_main_region_main_operation_On_r1_Warning();
		void enact_main_region_main_evaluation_ShutdownState();
		void enact_main_region_main_evaluation_SelfSteeringState();
		void enseq_main_region_main_default();
		void enseq_main_region_main_operation_Off_default();
		void enseq_main_region_main_operation_On_default();
		void enseq_main_region_main_operation_On_r1_NormalOperation_default();
		void enseq_main_region_main_operation_On_r1_Warning_default();
		void enseq_main_region_main_evaluation_working_default();
		void enseq_main_region_main_evaluation_ShutdownState_default();
		void enseq_main_region_main_evaluation_SelfSteeringState_default();
		void enseq_main_region_default();
		void enseq_main_region_main_operation_default();
		void enseq_main_region_main_operation_On_r1_default();
		void enseq_main_region_main_evaluation_default();
		void exseq_main_region_main_operation_Off();
		void exseq_main_region_main_operation_On();
		void exseq_main_region_main_operation_On_r1_NormalOperation();
		void exseq_main_region_main_operation_On_r1_Warning();
		void exseq_main_region_main_evaluation_working();
		void exseq_main_region_main_evaluation_ShutdownState();
		void exseq_main_region_main_evaluation_SelfSteeringState();
		void exseq_main_region();
		void exseq_main_region_main_operation_On_r1();
		void react_main_region_main_operation__choice_0();
		void react_main_region_main_evaluation__choice_0();
		void react_main_region_main_operation_On_r1__entry_Default();
		void react_main_region_main_operation__entry_Default();
		void react_main_region_main_evaluation__entry_Default();
		void react_main_region__entry_Default();
		sc_boolean react();
		sc_boolean main_region_main_react(const sc_boolean try_transition);
		sc_boolean main_region_main_operation_Off_react(const sc_boolean try_transition);
		sc_boolean main_region_main_operation_On_react(const sc_boolean try_transition);
		sc_boolean main_region_main_operation_On_r1_NormalOperation_react(const sc_boolean try_transition);
		sc_boolean main_region_main_operation_On_r1_Warning_react(const sc_boolean try_transition);
		sc_boolean main_region_main_evaluation_working_react(const sc_boolean try_transition);
		sc_boolean main_region_main_evaluation_ShutdownState_react(const sc_boolean try_transition);
		sc_boolean main_region_main_evaluation_SelfSteeringState_react(const sc_boolean try_transition);
		void clearInEvents();
		void clearOutEvents();
		
		
		
		
};




#endif /* MAINCTRL_H_ */
